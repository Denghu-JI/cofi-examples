
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "cofi-examples/generated/linear_regression.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_cofi-examples_generated_linear_regression.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_cofi-examples_generated_linear_regression.py:


Polynomial Linear Regression
============================

To get started, we look at a simple linear regression example with
``cofi``.

We have a set of noisy data values, Y, measured at known locations, X,
and wish to find the best fit degree 3 polynomial.

The function we are going to fit is: :math:`y=-6-5x+2x^2+x^3`

Table of contents
-----------------

-  `Introduction <#introduction>`__
-  Step 0 - `Import modules <#import>`__
-  Step 1 - `Define the problem <#problem>`__
-  Step 2 - `Define the inversion options <#options>`__
-  Step 3 - `Run the inversion <#inversion>`__
-  Step 4 - `Check out the result <#result>`__
-  Summary - `a clean version of code above <#review>`__
-  Next - `switching to a different inversion approach <#switch>`__

Introduction 
------------

In the workflow of ``cofi``, there are three main components:
``BaseProblem``, ``InversionOptions``, and ``Inversion``.

-  ``BaseProblem`` defines three things: 1) the forward problem; 2) the
   inversion parameter (model) space; and 3) the objective function to
   be optimised
-  ``InversionOptions`` describes details about how one wants to run the
   inversion, including the inversion approach, backend tool and
   solver-specific parameters.
-  ``Inversion`` can be seen as an inversion engine that takes in the
   above two as information, and will produce an ``InversionResult``
   upon running.

For each of the above components, there’s a ``summary()`` method to
check the current status.

So a common workflow includes 4 steps:

1. define ``BaseProblem``. This can be done:

   -  either: through a series of set functions

      ::

         inv_problem = BaseProblem()
         inv_problem.set_objective(some_function_here)
         inv_problem.set_initial_model(a_starting_point)

   -  or: by subclassing ``BaseProblem``

      ::

         class MyOwnProblem(BaseProblem):
             def __init__(self, initial_model, whatever_I_want_to_pass_in):
                 self.initial_model = initial_model
                 self.whatever_I_want_to_pass_in = whatever_I_want_to_pass_in
             def objective(self, model):
                 return some_objective_function_value

2. define ``InversionOptions``. Some useful methods include:

   -  ``set_solving_method()`` and ``suggest_tools()``. Once you’ve set
      a solving method (from “least squares” and “optimisation”, more
      will be supported), you can use ``suggest_tools()`` to see a list
      of backend tools to choose from.

3. start an ``Inversion``. This step is common:

   ::

      inv = Inversion(inv_problem, inv_options)
      result = inv.run()

4. analyse the result, workflow and redo your experiments with different
   ``InversionOptions``

.. GENERATED FROM PYTHON SOURCE LINES 88-93

--------------

0. Import modules 
-----------------


.. GENERATED FROM PYTHON SOURCE LINES 93-102

.. code-block:: default


    import numpy as np
    import matplotlib.pyplot as plt

    from cofi import BaseProblem, InversionOptions, Inversion

    np.random.seed(42)









.. GENERATED FROM PYTHON SOURCE LINES 103-135

--------------

1. Define the problem 
---------------------

A list of functions/properties that can be set to ``BaseProblem`` so
far:

-  ``set_objective()``
-  ``set_gradient()``
-  ``set_hessian()``
-  ``set_hessian_times_vector()``
-  ``set_residual()``
-  ``set_jacobian()``
-  ``set_jacobian_times_vector()``
-  ``set_data_misfit()``
-  ``set_regularisation()``
-  ``set_dataset()``
-  ``set_dataset_from_file()``
-  ``set_initial_model()``
-  ``set_model_shape()``
-  ``set_bounds``
-  ``set_constraints``
-  ``name`` (only useful when displaying this problem, no functional
   use)

Other useful functions:

-  ``defined_components()`` (review what have been set)
-  ``summary()`` (better displayed information)
-  ``suggest_solvers()``


.. GENERATED FROM PYTHON SOURCE LINES 135-166

.. code-block:: default


    # generate data with random Gaussian noise
    basis_func = lambda x: np.array([x**i for i in range(4)]).T               # x -> G
    _m_true = np.array([-6,-5,2,1])                                           # m

    sample_size = 20                                                          # N
    x = np.random.choice(np.linspace(-3.5,2.5), size=sample_size)             # x
    forward_func = lambda m: basis_func(x) @ m                                # m -> y_synthetic
    y_observed = forward_func(_m_true) + np.random.normal(0,1,sample_size)    # d

    ############## PLOTTING ###############################################################
    _x_plot = np.linspace(-3.5,2.5)
    _G_plot = basis_func(_x_plot)
    _y_plot = _G_plot @ _m_true
    plt.figure(figsize=(12,8))
    plt.plot(_x_plot, _y_plot, color="darkorange", label="true model")
    plt.scatter(x, y_observed, color="lightcoral", label="observed data")
    plt.xlabel("X")
    plt.ylabel("Y")
    _=plt.legend()

    # define the problem
    inv_problem = BaseProblem()
    inv_problem.name = "Polynomial Regression"
    inv_problem.set_dataset(x, y_observed)
    inv_problem.set_forward(forward_func)
    inv_problem.set_jacobian(basis_func(x))

    inv_problem.summary()





.. image-sg:: /cofi-examples/generated/images/sphx_glr_linear_regression_001.png
   :alt: linear regression
   :srcset: /cofi-examples/generated/images/sphx_glr_linear_regression_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Summary for inversion problem: Polynomial Regression
    =====================================================================
    Model shape: Unknown
    ---------------------------------------------------------------------
    List of functions/properties set by you:
    ['jacobian', 'forward', 'dataset']
    ---------------------------------------------------------------------
    List of functions/properties created based on what you have provided:
    ['residual', 'jacobian_times_vector']
    ---------------------------------------------------------------------
    List of functions/properties not set by you:
    ['objective', 'gradient', 'hessian', 'hessian_times_vector', 'residual', 'jacobian_times_vector', 'data_misfit', 'regularisation', 'initial_model', 'model_shape', 'bounds', 'constraints']




.. GENERATED FROM PYTHON SOURCE LINES 167-172

--------------

2. Define the inversion options 
-------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 172-182

.. code-block:: default


    inv_options = InversionOptions()
    inv_options.summary()

    inv_options.suggest_tools()

    inv_options.set_solving_method("linear least square")
    inv_options.summary()






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Summary for inversion options
    =============================
    Solving method: None set
    Use `suggest_solving_methods()` to check available solving methods.
    -----------------------------
    Backend tool: `scipy.optimize.minimize (by default)` - SciPy's optimisers that minimises a scalar function with respect to one or more variables, check SciPy's documentation page for a list of methods
    References: ['https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html']
    Use `suggest_tools()` to check available backend tools.
    -----------------------------
    Solver-specific parameters: None set
    Use `suggest_solver_params()` to check required/optional solver-specific parameters.
    Here's a complete list of inversion solvers supported by CoFI (grouped by methods):
    {
        "optimisation": [
            "scipy.optimize.minimize",
            "scipy.optimize.least_squares"
        ],
        "linear least square": [
            "scipy.linalg.lstsq"
        ]
    }
    Summary for inversion options
    =============================
    Solving method: linear least square
    Use `suggest_solving_methods()` to check available solving methods.
    -----------------------------
    Backend tool: `scipy.linalg.lstsq (by default)` - SciPy's wrapper function over LAPACK's linear least-squares solver, using 'gelsd', 'gelsy' (default), or 'gelss' as backend driver
    References: ['https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html', 'https://www.netlib.org/lapack/lug/node27.html']
    Use `suggest_tools()` to check available backend tools.
    -----------------------------
    Solver-specific parameters: None set
    Use `suggest_solver_params()` to check required/optional solver-specific parameters.




.. GENERATED FROM PYTHON SOURCE LINES 183-191

--------------

As the “summary” suggested, you’ve set the solving method, so you can
skip the step of setting a backend tool because there’s a default one.

If there are more backend tool options, then use the following function
to see available options and set your desired backend solver.


.. GENERATED FROM PYTHON SOURCE LINES 191-198

.. code-block:: default


    inv_options.suggest_tools()

    inv_options.set_tool("scipy.linalg.lstsq")
    inv_options.summary()






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Based on the solving method you've set, the following tools are suggested:
    ['scipy.linalg.lstsq']

    Use `InversionOptions.set_tool(tool_name)` to set a specific tool from above
    Use `InversionOptions.set_solving_method(method_name)` to change solving method
    Use `InversionOptions.unset_solving_method()` if you'd like to see more options
    Check CoFI documentation 'Advanced Usage' section for how to plug in your own solver
    Summary for inversion options
    =============================
    Solving method: linear least square
    Use `suggest_solving_methods()` to check available solving methods.
    -----------------------------
    Backend tool: `scipy.linalg.lstsq` - SciPy's wrapper function over LAPACK's linear least-squares solver, using 'gelsd', 'gelsy' (default), or 'gelss' as backend driver
    References: ['https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html', 'https://www.netlib.org/lapack/lug/node27.html']
    Use `suggest_tools()` to check available backend tools.
    -----------------------------
    Solver-specific parameters: None set
    Use `suggest_solver_params()` to check required/optional solver-specific parameters.




.. GENERATED FROM PYTHON SOURCE LINES 199-204

--------------

3. Start an inversion 
---------------------


.. GENERATED FROM PYTHON SOURCE LINES 204-214

.. code-block:: default


    inv = Inversion(inv_problem, inv_options)
    inv.summary()

    inv_result = inv.run()
    inv_result.success

    inv_result.summary()






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Summary for Inversion
    =======================================
    Inversion hasn't started, try `inversion.run()` to see result
    ---------------------------------------
    With inversion solver defined as below:

    Summary for inversion options
    Solving method: linear least square
    Use `suggest_solving_methods()` to check available solving methods.
    Backend tool: `scipy.linalg.lstsq` - SciPy's wrapper function over LAPACK's linear least-squares solver, using 'gelsd', 'gelsy' (default), or 'gelss' as backend driver
    References: ['https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html', 'https://www.netlib.org/lapack/lug/node27.html']
    Use `suggest_tools()` to check available backend tools.
    Solver-specific parameters: None set
    Use `suggest_solver_params()` to check required/optional solver-specific parameters.
    ---------------------------------------
    For inversion problem defined as below:

    Summary for inversion problem: Polynomial Regression
    Model shape: Unknown
    List of functions/properties set by you:
    ['jacobian', 'forward', 'dataset']
    List of functions/properties created based on what you have provided:
    ['residual', 'jacobian_times_vector']
    List of functions/properties not set by you:
    ['objective', 'gradient', 'hessian', 'hessian_times_vector', 'residual', 'jacobian_times_vector', 'data_misfit', 'regularisation', 'initial_model', 'model_shape', 'bounds', 'constraints']
    Summary for inversion result
    ============================
    SUCCESS
    ----------------------------
    model: [-5.71964359 -5.10903808  1.82553662  0.97472374]
    sum of squared residuals: 14.961507878871286
    effective rank: 4
    singular values: [61.36381472  8.31821387  4.03376312  1.96325721]




.. GENERATED FROM PYTHON SOURCE LINES 215-220

--------------

4. Check back your problem setting, inversion setting & result 
--------------------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 220-239

.. code-block:: default


    inv.summary()

    y_synthetic = inv_problem.forward(inv_result.model)

    ############## PLOTTING ###############################################################
    _x_plot = np.linspace(-3.5,2.5)
    _G_plot = basis_func(_x_plot)
    _y_plot = _G_plot @ _m_true
    _y_synth = _G_plot @ inv_result.model
    plt.figure(figsize=(12,8))
    plt.plot(_x_plot, _y_plot, color="darkorange", label="true model")
    plt.plot(_x_plot, _y_synth, color="seagreen", label="least squares solution")
    plt.scatter(x, y_observed, color="lightcoral", label="original data")
    plt.xlabel("X")
    plt.ylabel("Y")
    _=plt.legend()





.. image-sg:: /cofi-examples/generated/images/sphx_glr_linear_regression_002.png
   :alt: linear regression
   :srcset: /cofi-examples/generated/images/sphx_glr_linear_regression_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Summary for Inversion
    =======================================
    Completed with the following result:

    Summary for inversion result
    SUCCESS
    model: [-5.71964359 -5.10903808  1.82553662  0.97472374]
    sum of squared residuals: 14.961507878871286
    effective rank: 4
    singular values: [61.36381472  8.31821387  4.03376312  1.96325721]
    ---------------------------------------
    With inversion solver defined as below:

    Summary for inversion options
    Solving method: linear least square
    Use `suggest_solving_methods()` to check available solving methods.
    Backend tool: `scipy.linalg.lstsq` - SciPy's wrapper function over LAPACK's linear least-squares solver, using 'gelsd', 'gelsy' (default), or 'gelss' as backend driver
    References: ['https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html', 'https://www.netlib.org/lapack/lug/node27.html']
    Use `suggest_tools()` to check available backend tools.
    Solver-specific parameters: None set
    Use `suggest_solver_params()` to check required/optional solver-specific parameters.
    ---------------------------------------
    For inversion problem defined as below:

    Summary for inversion problem: Polynomial Regression
    Model shape: Unknown
    List of functions/properties set by you:
    ['jacobian', 'forward', 'dataset']
    List of functions/properties created based on what you have provided:
    ['residual', 'jacobian_times_vector']
    List of functions/properties not set by you:
    ['objective', 'gradient', 'hessian', 'hessian_times_vector', 'residual', 'jacobian_times_vector', 'data_misfit', 'regularisation', 'initial_model', 'model_shape', 'bounds', 'constraints']
    List of functions/properties got used by the backend tool:
    ['jacobian', 'dataset']




.. GENERATED FROM PYTHON SOURCE LINES 240-243

Here we see the least squares solver (green curve) fits all of the data
well and is a close approximation of the true curve (orange).


.. GENERATED FROM PYTHON SOURCE LINES 246-254

--------------

5. Summary: a cleaner version of the above example 
--------------------------------------------------

For review purpose, here are the minimal set of commands we’ve used to
produce the above result:


.. GENERATED FROM PYTHON SOURCE LINES 254-288

.. code-block:: default


    ######## Import and set random seed
    import numpy as np
    from cofi import BaseProblem, InversionOptions, Inversion

    np.random.seed(42)

    ######## Write code for your forward problem
    _m_true = np.array([-6,-5,2,1])                                            # m
    _sample_size = 20                                                          # N
    x = np.random.choice(np.linspace(-3.5,2.5), size=_sample_size)             # x
    forward_func = lambda m: (np.array([x**i for i in range(4)]).T) @ m        # m -> y_synthetic
    y_observed = forward_func(_m_true) + np.random.normal(0,1,_sample_size)    # d

    ######## Attach above information to a `BaseProblem`
    inv_problem = BaseProblem()
    inv_problem.name = "Polynomial Regression"
    inv_problem.set_dataset(x, y_observed)
    inv_problem.set_forward(forward_func)
    inv_problem.set_jacobian(basis_func(x))

    ######## Specify how you'd like the inversion to run (via an `InversionOptions`)
    inv_options = InversionOptions()
    inv_options.set_tool("scipy.linalg.lstsq")

    ######## Pass `BaseProblem` and `InversionOptions` into `Inversion` and run
    inv = Inversion(inv_problem, inv_options)
    inv_result = inv.run()

    ######## Now check out the result
    print(f"The inversion result from `scipy.linalg.lstsq`: {inv_result.model}\n")
    inv_result.summary()






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The inversion result from `scipy.linalg.lstsq`: [-5.71964359 -5.10903808  1.82553662  0.97472374]

    Summary for inversion result
    ============================
    SUCCESS
    ----------------------------
    model: [-5.71964359 -5.10903808  1.82553662  0.97472374]
    sum of squared residuals: 14.961507878871286
    effective rank: 4
    singular values: [61.36381472  8.31821387  4.03376312  1.96325721]




.. GENERATED FROM PYTHON SOURCE LINES 289-309

--------------

6. Switching to a different inversion approach 
----------------------------------------------

Alternatively, you can switch to a different inversion solver easily.
Here we use a plain optimizer ``scipy.optimize.minimize`` to demonstrate
this ability.

For this backend solver to run successfully, some additional information
should be provided, otherwise we will raise an error to notify what
additional information is required by the solver.

There are different ways of defining information - Here in the code
below, after we make clear how to calculate the data misfit and
regularisation, the objective function is generated for you based on the
forward function and dataset. Alternatively, you can pass in an
objective function directly using
``inv_problem.set_objective(your_objective_func)``


.. GENERATED FROM PYTHON SOURCE LINES 309-342

.. code-block:: default


    ######## Provide additional information
    inv_problem.set_initial_model(np.ones(4))
    inv_problem.set_data_misfit("L2")
    inv_problem.set_regularisation("L2", 0)

    ######## Set a different tool
    inv_options_2 = InversionOptions()
    inv_options_2.set_tool("scipy.optimize.minimize")

    ######## Run it
    inv_2 = Inversion(inv_problem, inv_options_2)
    inv_result_2 = inv_2.run()

    ######## Check result
    print(f"The inversion result from `scipy.optimize.minimize`: {inv_result_2.model}\n")
    inv_result_2.summary()

    ######## Plot all together
    _x_plot = np.linspace(-3.5,2.5)
    _G_plot = basis_func(_x_plot)
    _y_plot = _G_plot @ _m_true
    _y_synth_2 = _G_plot @ inv_result_2.model
    plt.figure(figsize=(12,8))
    plt.plot(_x_plot, _y_plot, color="darkorange", label="true model")
    plt.plot(_x_plot, _y_synth, color="seagreen", label="least squares solution")
    plt.plot(_x_plot, _y_synth_2, color="cornflowerblue", label="optimisation solution")
    plt.scatter(x, y_observed, color="lightcoral", label="original data")
    plt.xlabel("X")
    plt.ylabel("Y")
    _=plt.legend()





.. image-sg:: /cofi-examples/generated/images/sphx_glr_linear_regression_003.png
   :alt: linear regression
   :srcset: /cofi-examples/generated/images/sphx_glr_linear_regression_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The inversion result from `scipy.optimize.minimize`: [-5.71964263 -5.1090375   1.825536    0.97472351]

    Summary for inversion result
    ============================
    SUCCESS
    ----------------------------
    fun: 0.19340054213264107
    jac: [ 1.49011612e-08 -2.98023224e-08  8.94069672e-08 -2.98023224e-07]
    hess_inv: [[15.11931178  4.64156816 -6.40021776 -2.00012827]
     [ 4.64156816  6.76281278 -2.59251171 -1.41203858]
     [-6.40021776 -2.59251171  4.03559717  1.32843938]
     [-2.00012827 -1.41203858  1.32843938  0.52744873]]
    nfev: 140
    njev: 28
    status: 0
    message: Optimization terminated successfully.
    nit: 24
    model: [-5.71964263 -5.1090375   1.825536    0.97472351]




.. GENERATED FROM PYTHON SOURCE LINES 343-346

Here we see the (blue curve) is also a relatively good approximation of
the true curve (orange).


.. GENERATED FROM PYTHON SOURCE LINES 349-350

--------------


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.302 seconds)


.. _sphx_glr_download_cofi-examples_generated_linear_regression.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: linear_regression.py <linear_regression.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: linear_regression.ipynb <linear_regression.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
